<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-9999</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create
/*
global.silhouetteActive = true;

prevViewX = view_xview[0];
prevViewY = view_yview[0];

sur_silhouette = noone;

//Create vertex format for the occluder geometry (100% standard vertex format)
vertex_format_begin();
vertex_format_add_position();
vertex_format_add_colour();
vertex_format_add_textcoord();
vft_silhouette = vertex_format_end();

//Create depth-ordered priority queue to draw occluders in the correct order
var pri = ds_priority_create();
with( obj_occluder ) ds_priority_add( pri, id, y );

//Create occluder vertex buffer
tex_silhouette = sprite_get_texture( spr_occluder, 0 );
vbf_silhouette = vertex_create_buffer();
var vbuff = vbf_silhouette;
vertex_begin( vbf_silhouette, vft_silhouette );

while( !ds_priority_empty( pri ) ) {
    
    //Using the scope of the next occluder in the queue...
    with( ds_priority_delete_min( pri ) ) {
        
        //Work out the graphical limits of the instance
        var instL = x - sprite_get_xoffset( sprite_index );
        var instT = y - sprite_get_yoffset( sprite_index );
        var instR = instL + sprite_get_width( sprite_index );
        var instB = instT + sprite_get_height( sprite_index );
        
        //Set the blend colour for the top (lowest y-value) of the occluder mask
        var c_blend = make_colour_rgb( min( 255, sprite_get_height( sprite_index ) ), 0, 0 );
        
        var sprUVs = sprite_get_uvs( sprite_index, 1 );
        
        //TL tri
        vertex_position( vbuff, instL, instT ); vertex_colour( vbuff, c_blend, 1 ); vertex_texcoord( vbuff, sprUVs[0], sprUVs[1] );
        vertex_position( vbuff, instL, instB ); vertex_colour( vbuff, c_black, 1 ); vertex_texcoord( vbuff, sprUVs[0], sprUVs[3] );
        vertex_position( vbuff, instR, instT ); vertex_colour( vbuff, c_blend, 1 ); vertex_texcoord( vbuff, sprUVs[2], sprUVs[1] );
    
        //BR tri
        vertex_position( vbuff, instL, instB ); vertex_colour( vbuff, c_black, 1 ); vertex_texcoord( vbuff, sprUVs[0], sprUVs[3] );
        vertex_position( vbuff, instR, instT ); vertex_colour( vbuff, c_blend, 1 ); vertex_texcoord( vbuff, sprUVs[2], sprUVs[1] );
        vertex_position( vbuff, instR, instB ); vertex_colour( vbuff, c_black, 1 ); vertex_texcoord( vbuff, sprUVs[2], sprUVs[3] );
        
    }
}

vertex_end( vbuff );
vertex_freeze( vbuff );

ds_priority_destroy( pri );
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Step
/*
if ( keyboard_check_pressed( vk_escape ) ) game_end();
if ( keyboard_check_pressed( vk_f4 ) ) window_set_fullscreen( !window_get_fullscreen() );
if ( keyboard_check_pressed( vk_space ) ) global.silhouetteActive = !global.silhouetteActive;

view_xview[0] += ( keyboard_check( vk_right ) - keyboard_check( vk_left ) ) * 4;
view_yview[0] += ( keyboard_check( vk_down  ) - keyboard_check( vk_up   ) ) * 4;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Begin
/*
if ( global.silhouetteActive ) {
    
    var regen = false;
    
    //Recreate surface if window is minimised
    if ( !surface_exists( sur_silhouette ) ) {
        regen = true;
        sur_silhouette = surface_create( view_wview[0], view_hview[0] );
    }
    
    //Order regeneration if the view position has changed
    if ( view_xview[0] != prevViewX ) or ( view_yview[0] != prevViewY ) regen = true;
    
    if ( regen ) {
        
        surface_set_target( sur_silhouette );
        draw_clear_alpha( c_black, 0 );
        
        d3d_transform_stack_push();
        d3d_transform_set_translation( -view_xview[0], -view_yview[0], 0 ); //Correct for view position
        
        shader_set( shd_mask ); //Ignore texture RGB - we're interested in the alpha channel from the texture only
        vertex_submit( vbf_silhouette, pr_trianglelist, tex_silhouette );
        shader_reset();
        
        d3d_transform_stack_pop();
        
        surface_reset_target();
        
    }

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw GUI
/*
var str = "Frame time (ms) = " + string( floor( 1000000 / fps_real ) / 1000 );
str += "#Press space to switch silhouette on/off";
str += "#Press F4 to switch fullscreen";
str += "#Arrow keys to move the view";
draw_set_colour( c_black );
draw_text( 6, 6, str );
draw_set_colour( c_white );
draw_text( 5, 5, str );
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
